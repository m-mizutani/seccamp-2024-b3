// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"cloud.google.com/go/pubsub"
	"context"
	"sync"
)

// Ensure, that InquirerMock does implement Inquirer.
// If this is not the case, regenerate this file with moq.
var _ Inquirer = &InquirerMock{}

// InquirerMock is a mock implementation of Inquirer.
//
//	func TestSomethingThatUsesInquirer(t *testing.T) {
//
//		// make and configure a mocked Inquirer
//		mockedInquirer := &InquirerMock{
//			QueryFunc: func(ctx context.Context, query string) (RowIterator, error) {
//				panic("mock out the Query method")
//			},
//		}
//
//		// use mockedInquirer in code that requires Inquirer
//		// and then make assertions.
//
//	}
type InquirerMock struct {
	// QueryFunc mocks the Query method.
	QueryFunc func(ctx context.Context, query string) (RowIterator, error)

	// calls tracks calls to the methods.
	calls struct {
		// Query holds details about calls to the Query method.
		Query []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
		}
	}
	lockQuery sync.RWMutex
}

// Query calls QueryFunc.
func (mock *InquirerMock) Query(ctx context.Context, query string) (RowIterator, error) {
	if mock.QueryFunc == nil {
		panic("InquirerMock.QueryFunc: method is nil but Inquirer.Query was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
	}{
		Ctx:   ctx,
		Query: query,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(ctx, query)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedInquirer.QueryCalls())
func (mock *InquirerMock) QueryCalls() []struct {
	Ctx   context.Context
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Query string
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// Ensure, that RowIteratorMock does implement RowIterator.
// If this is not the case, regenerate this file with moq.
var _ RowIterator = &RowIteratorMock{}

// RowIteratorMock is a mock implementation of RowIterator.
//
//	func TestSomethingThatUsesRowIterator(t *testing.T) {
//
//		// make and configure a mocked RowIterator
//		mockedRowIterator := &RowIteratorMock{
//			NextFunc: func(dst interface{}) error {
//				panic("mock out the Next method")
//			},
//		}
//
//		// use mockedRowIterator in code that requires RowIterator
//		// and then make assertions.
//
//	}
type RowIteratorMock struct {
	// NextFunc mocks the Next method.
	NextFunc func(dst interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Next holds details about calls to the Next method.
		Next []struct {
			// Dst is the dst argument value.
			Dst interface{}
		}
	}
	lockNext sync.RWMutex
}

// Next calls NextFunc.
func (mock *RowIteratorMock) Next(dst interface{}) error {
	if mock.NextFunc == nil {
		panic("RowIteratorMock.NextFunc: method is nil but RowIterator.Next was just called")
	}
	callInfo := struct {
		Dst interface{}
	}{
		Dst: dst,
	}
	mock.lockNext.Lock()
	mock.calls.Next = append(mock.calls.Next, callInfo)
	mock.lockNext.Unlock()
	return mock.NextFunc(dst)
}

// NextCalls gets all the calls that were made to Next.
// Check the length with:
//
//	len(mockedRowIterator.NextCalls())
func (mock *RowIteratorMock) NextCalls() []struct {
	Dst interface{}
} {
	var calls []struct {
		Dst interface{}
	}
	mock.lockNext.RLock()
	calls = mock.calls.Next
	mock.lockNext.RUnlock()
	return calls
}

// Ensure, that PublisherMock does implement Publisher.
// If this is not the case, regenerate this file with moq.
var _ Publisher = &PublisherMock{}

// PublisherMock is a mock implementation of Publisher.
//
//	func TestSomethingThatUsesPublisher(t *testing.T) {
//
//		// make and configure a mocked Publisher
//		mockedPublisher := &PublisherMock{
//			PublishFunc: func(ctx context.Context, msg *pubsub.Message) PublishResult {
//				panic("mock out the Publish method")
//			},
//		}
//
//		// use mockedPublisher in code that requires Publisher
//		// and then make assertions.
//
//	}
type PublisherMock struct {
	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, msg *pubsub.Message) PublishResult

	// calls tracks calls to the methods.
	calls struct {
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg *pubsub.Message
		}
	}
	lockPublish sync.RWMutex
}

// Publish calls PublishFunc.
func (mock *PublisherMock) Publish(ctx context.Context, msg *pubsub.Message) PublishResult {
	if mock.PublishFunc == nil {
		panic("PublisherMock.PublishFunc: method is nil but Publisher.Publish was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg *pubsub.Message
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, msg)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//
//	len(mockedPublisher.PublishCalls())
func (mock *PublisherMock) PublishCalls() []struct {
	Ctx context.Context
	Msg *pubsub.Message
} {
	var calls []struct {
		Ctx context.Context
		Msg *pubsub.Message
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Ensure, that PublishResultMock does implement PublishResult.
// If this is not the case, regenerate this file with moq.
var _ PublishResult = &PublishResultMock{}

// PublishResultMock is a mock implementation of PublishResult.
//
//	func TestSomethingThatUsesPublishResult(t *testing.T) {
//
//		// make and configure a mocked PublishResult
//		mockedPublishResult := &PublishResultMock{
//			GetFunc: func(ctx context.Context) (string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedPublishResult in code that requires PublishResult
//		// and then make assertions.
//
//	}
type PublishResultMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *PublishResultMock) Get(ctx context.Context) (string, error) {
	if mock.GetFunc == nil {
		panic("PublishResultMock.GetFunc: method is nil but PublishResult.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedPublishResult.GetCalls())
func (mock *PublishResultMock) GetCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}
